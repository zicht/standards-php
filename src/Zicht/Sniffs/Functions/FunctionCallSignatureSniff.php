<?php
/**
 * @copyright Zicht Online <https://zicht.nl>
 */

namespace Zicht\Sniffs\Functions;

use PHP_CodeSniffer\Files\File;
use PHP_CodeSniffer\Standards\PEAR\Sniffs\Functions\FunctionCallSignatureSniff as PearFunctionCallSignatureSniff;
use PHP_CodeSniffer\Util\Common;
use PHP_CodeSniffer\Util\Tokens;

class FunctionCallSignatureSniff extends PearFunctionCallSignatureSniff
{
    const IGNORE_CODES_TO_ALLOW = ['ContentAfterOpenBracket', 'CloseBracketLine'];

    /**
     * Override PEAR Sniff to allow function call opening parenthesis and array square brackets on the same line
     *
     * We're checking if there's only one argument, which should be an array or could be a closure. If so,
     * we're changing the PHPCS ruleset on the fly to ignore the two error codes that are being used to add errors
     * for this by the parent sniff (PEAR.Functions.FunctionCallSignature.ContentAfterOpenBracket and
     * PEAR.Functions.FunctionCallSignature.CloseBracketLine)
     *
     * {@inheritDoc}
     */
    public function processMultiLineCall(File $phpcsFile, $stackPtr, $openBracket, $tokens)
    {
        $allow = true;
        $prevRulesConfig = [];

        $next = $phpcsFile->findNext(Tokens::$emptyTokens, ($openBracket + 1), null, true);
        if (!in_array($tokens[$next]['code'], [T_ARRAY, T_OPEN_SHORT_ARRAY, T_ARRAY_CAST, T_CLOSURE], true)) {
            parent::processMultiLineCall($phpcsFile, $stackPtr, $openBracket, $tokens);
            return;
        }

        // Find out if there are more than one arguments
        $closeBracket  = $tokens[$openBracket]['parenthesis_closer'];
        $nextSeparator = $openBracket;
        $find = [T_COMMA, T_VARIABLE, T_CLOSURE, T_OPEN_SHORT_ARRAY];
        while (false !== ($nextSeparator = $phpcsFile->findNext($find, ($nextSeparator + 1), $closeBracket))) {
            if ($tokens[$nextSeparator]['code'] === T_CLOSURE) {
                $nextSeparator = $tokens[$nextSeparator]['scope_closer']; // Skip closure body
                continue;
            } elseif ($tokens[$nextSeparator]['code'] === T_OPEN_SHORT_ARRAY) {
                $nextSeparator = $tokens[$nextSeparator]['bracket_closer']; // Skip short array body
                continue;
            }
            // Make sure the comma or variable belongs directly to this function call,
            // and is not inside a nested function call or array.
            $brackets = $tokens[$nextSeparator]['nested_parenthesis'];
            $lastBracket = array_pop($brackets);
            if ($lastBracket !== $closeBracket) {
                continue;
            }

            if ($tokens[$nextSeparator]['code'] === T_COMMA) {
                // Found a comma, and thus multiple arguments are present: do not allow
                $allow = false;
                break;
            }
        }

        if ($allow) {
            foreach (static::IGNORE_CODES_TO_ALLOW as $code) {
                /* Opening array or closure on the same line as the function call is allowed.
                   Tempoarily ignore the errors generated for this by the PEAR.Functions.FunctionCallSignature
                   sniff (codes ContentAfterOpenBracket and CloseBracketLine).
                   Remember the old ruleset config. */
                $sniffCode = sprintf('%s.%s', Common::getSniffCode(static::class), $code);
                if (array_key_exists($sniffCode, $phpcsFile->ruleset->ruleset)) {
                    $prevRulesConfig[$sniffCode] = $phpcsFile->ruleset->ruleset[$sniffCode];
                }
                $phpcsFile->ruleset->ruleset[$sniffCode] = ['severity' => 0];
            }
        }

        parent::processMultiLineCall($phpcsFile, $stackPtr, $openBracket, $tokens);

        if ($allow) {
            foreach (static::IGNORE_CODES_TO_ALLOW as $code) {
                /* Restore the ruleset config for the errors generated by the
                   PEAR.Functions.FunctionCallSignature sniff */
                $sniffCode = sprintf('%s.%s', Common::getSniffCode(static::class), $code);
                if (array_key_exists($sniffCode, $prevRulesConfig)) {
                    $phpcsFile->ruleset->ruleset[$sniffCode] = $prevRulesConfig[$sniffCode];
                } else {
                    unset($phpcsFile->ruleset->ruleset[$sniffCode]);
                }
            }
        }
    }
}
